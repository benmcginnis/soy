{"prompt":"// features\/demoAutoescapeFalse.soy\n{namespace features}\n\/**\n * @param italicHtml\n *\/\n{template .demoAutoescapeFalse}\n{$italicHtml}<br>{$italicHtml|escapeHtml}<br>\n{\/template}","completion":" // features\/DemoAutoescapeFalse.tsx\nimport * as React from 'react';\nimport { escapeHtml } from ..\/soyfuncs';\n\nexport interface DemoAutoescapeFalseProps {\n  italicHtml: any;\n}\n\n\/**\n * Demo autoescape false.\n * @param props DemoAutoescapeFalseProps\n * @param props.italicHtml A string surrounded by HTML italics tags.\n *\/\nexport function DemoAutoescapeFalse(props: DemoAutoescapeFalseProps) {\n  const { italicHtml } = props;\n  return (\n    <>\n      {\/* Note: Use autoescape=\"false\" with care, as more cross-site scripting bugs may slip through. *\/}\n      {italicHtml}<br\/> {\/* no autoescaping will be applied *\/}\n      {escapeHtml(italicHtml)}<br\/>  {\/* escapeHtml directive applies HTML escaping *\/}\n    <\/>\n  )\n} END"}
{"prompt":"// features\/demoLineJoining.soy\n{namespace features}\n\/** *\/\n{template .demoLineJoining}\nFirst second.<br><i>First<\/i>second.<br>First{''}second.<br><i>First<\/i> second.<br>Firstsecond.<br>\n{\/template}","completion":" // features\/DemoLineJoining.tsx\nimport * as React from 'react';\n\n\/**\n * Demo line joining.\n *\/\nexport const DemoLineJoining = () => {\n  return (\n    <>\n      {\/* Without any HTML or Soy tags at the end of the first line or start of the second line, the two} () *\/}\n      {\/* lines will be joined by adding a space. *\/}\n      First\n      second.<br\/>\n      {\/* With either an HTML or Soy tag bordering the join location (end of the first line or start of () *\/}\n      {\/* the second line), the lines will be joined without adding a space. *\/}\n      {\/* Example with HTML tag at end of first line: *\/}\n      <i>First<\/i>\n      second.<br\/>\n      {\/* Example with Soy tag at start of second line: () *\/}\n\n      First\n      {''}second.<br\/>\n      {\/* To add a space to a line-joining location where a space would not normally be added (because () *\/}\n      {\/* (it borders an HTML or Soy tag), use the {sp} tag. *\/}\n      <i>First<\/i>{' '}\n      second.<br\/>\n      {\/* To prevent a space from being added to a line-joining location where a space would normally be () *\/}\n      {\/* added, use the {nil} tag. This tag prints nothing (empty string), but causes the line-joining *\/}\n      {\/* location to border a Soy tag, thus preventing the line-joining space. *\/}\n      First{''}\n      second.<br\/>\n    <\/>\n  )\n} END"}
{"prompt":"// features\/demoPrint.soy\n{namespace features}\n\/**\n * @param boo\n * @param two\n *\/\n{template .demoPrint}\n{'Boo!'}<br>{'Boo!'}<br>{1 + 2}<br>{$boo}<br>{1 + $two}<br>{GLOBAL_INT}, {GLOBAL_BOOL}.<br>\n{\/template}","completion":" // features\/DemoPrint.tsx\nimport * as React from 'react';\nimport { GLOBAL_BOOL, GLOBAL_INT } from '..\/Globals';\nimport { print } from ..\/soyfuncs';\n\nexport interface DemoPrintProps {\n  boo: any;\n  two: any;\n}\n\n\/**\n * Demo 'print'.\n * @param props\n * @param props.boo Something scary.\n * @param props.two Preferably the number 2.\n *\/\nexport const DemoPrint = (props: DemoPrintProps) => {\n  const { boo, two } = props;\n  return (\n    <>\n      {print('Boo!')}<br\/> {\/* print a string *\/}\n      {'Boo!'}<br\/>  {\/* the command name 'print' is implied *\/}\n      {1 + 2}<br\/>  {\/* print the result of an expression *\/}\n      {boo}<br\/>  {\/* print a data value *\/}\n      {1 + two}<br\/>  {\/* print the result of an expression that uses a data value *\/}\n      {GLOBAL_INT}, {GLOBAL_BOOL.toString()}.<br\/>  {\/* print globals *\/}\n    <\/>\n  )\n}\n END"}
{"prompt":"// simple\/helloWorld.soy\n{namespace simple}\n\/** *\/\n{template .simple.helloWorld}\n{msg desc=\"Says hello to the world.\"}Hello world!{\/msg}\n{\/template}","completion":" // simple\/HelloWorld.tsx\nimport * as React from 'react';\nimport { Trans } from 'react-i18next'\n\n\/\/ Copyright 2008 Google Inc.\n\/\/\n\/\/ Licensed under the Apache License, Version 2.0 (the \"License\");\n\/\/ you may not use this file except in compliance with the License.\n\/\/ You may obtain a copy of the License at\n\/\/\n\/\/     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n\/\/\n\/\/ Unless required by applicable law or agreed to in writing, software\n\/\/ distributed under the License is distributed on an \"AS IS\" BASIS,\n\/\/ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\/\/ See the License for the specific language governing permissions and\n\/\/ limitations under the License.\n\n\/\/ Simple examples.\n\/\/ Author: Kai Huang\n\n\/**\n * Says hello to the world.\n *\/\nexport const HelloWorld = () => {\n  return (\n    <Trans i18nKey=\"Says hello to the world.\">\n      Hello world!\n    <\/Trans>\n  )\n}\n END"}
{"prompt":"// features\/bidiGlobalDir.soy\n{namespace features}\n\/** *\/\n{template .bidiGlobalDir}\n{bidiGlobalDir()}\n{\/template}","completion":" // features\/BidiGlobalDir.tsx\nimport * as React from 'react';\nimport { bidiGlobalDir } from ..\/soyfuncs';\n\n\/**\n * Template that outputs -1 in a right-to-left page and 1 in a left-to-right page, i.e. basically\n * exposes the results of Soy's bidiGlobalDir() to scripts.\n *\/\nexport const BidiGlobalDir = () => {\n  return (\n    <>\n      {bidiGlobalDir()}\n    <\/>\n  )\n} END"}
{"prompt":"// features\/buildCommaSeparatedList_.soy\n{namespace features}\n\/**\n * @param items\n *\/\n{template .buildCommaSeparatedList_}\n{for $item in $items}{if not isFirst($item)}, {\/if}{$item}{\/for}\n{\/template}","completion":" // features\/BuildCommaSeparatedList_.tsx\nimport * as React from 'react';\n\n\/**\n * @internal\n *\/\nexport interface BuildCommaSeparatedListProps_ {\n  items: string[];\n}\n\n\/**\n * Private helper to build a comma separated list.\n * @param props BuildCommaSeparatedListProps_\n * @param props.items The list of items.\n *\n * @internal\n *\/\nexport const BuildCommaSeparatedList_ = (props: BuildCommaSeparatedListProps_) => {\n  return (\n    <>\n      {props.items.map((item, index) => {\n        return (\n          <React.Fragment key={index}>\n            {(()=>{\n              if (!(index === 0)) {\n                return (\n                  <>\n                    ,{' '}\n                  <\/>\n                )\n              }\n            })()}\n            {item}\n          <\/React.Fragment>\n        )\n      })}\n    <\/>\n  )\n} END"}
{"prompt":"// features\/demoCallWithParam.soy\n{namespace features}\n\/**\n * @param name\n * @param companionName\n * @param destinations\n *\/\n{template .demoCallWithParam}\n{for $destination in $destinations}{call .tripReport_ data=\"all\"}{param destination: $destination\/}{\/call}<br>{if index($destination) % 2 == 0}{call .tripReport_}{param name: $companionName\/}{param destination: $destination\/}{\/call}<br>{\/if}{\/for}\n{\/template}","completion":" // features\/DemoCallWithParam.tsx\nimport * as React from 'react';\nimport { TripReport_ } from '.\/TripReport_';\n\nexport interface DemoCallWithParamProps {\n  name: any;\n  companionName: any;\n  destinations: any;\n}\n\n\/**\n * Demo 'call' with 'param's.\n * @param props DemoCallWithParamProps\n * @param props.name The name of the person who took the trips.\n * @param props.companionName The name of the person who went along for the odd-numbered trips only.\n * @param props.destinations List of destinations visited by this person.\n *\/\nexport const DemoCallWithParam = (props :DemoCallWithParamProps) => {\n  const { companionName, destinations } = props;\n  return (\n    <>\n      {destinations.map((destination :any, index :number)=>{\n        return (\n          <React.Fragment key={index}>\n            {\/* Pass the current template data and also pass a parameter. *\/}\n            {\/* Note: Only passing data=\"all\" is not sufficient for providing the 'destination' parameter of *\/}\n            {\/* the callee because $destination is a local variable here, not part of the template data *\/}\n            {\/* passed by data=\"all\". *\/}\n            <TripReport_ {...props} destination={destination} \/><br\/>\n            {(()=>{\n              if (index % 2 === 0) { \/\/ even index means odd-numbered trip since index is 0-based\n                \/\/ Pass two parameters.\n                return (\n                  <>\n                    <TripReport_ name={companionName} destination={destination} \/><br\/>\n                  <\/>\n                )\n              }\n            })()}\n          <\/React.Fragment>\n        )\n      })}\n    <\/>\n  )\n}\n END"}
{"prompt":"// features\/demoForeach.soy\n{namespace features}\n\/**\n * @param persons\n *\/\n{template .demoForeach}\n{for $person in $persons}{if isFirst($person)}First,{elseif isLast($person)}Finally,{else}Then{\/if} {if $person.numWaffles == 1}{$person.name} ate 1 waffle.{else}{$person.name} ate {$person.numWaffles} waffles.{\/if}<br>{ifempty}Nobody here ate any waffles.<br>{\/for}\n{\/template}","completion":" // features\/DemoForeach.tsx\nimport * as React from 'react';\n\nexport interface DemoForeachProps {\n  persons: any;\n}\n\n\/**\n * Demo 'foreach'.\n * @param props DemoForeachProps\n * @param props.persons List of persons. Each person must have 'name' and 'numWaffles'.\n *\/\nexport const DemoForeach = (props: DemoForeachProps ) => {\n  const { persons } = props;\n  return (\n    <>\n      {(()=>{\n        if (persons.length >= 0) {\n          return (\n            <>\n              {persons.map(\n                (person: any, index: number) => {\n                  return (\n                    <React.Fragment key={index}>\n                      <>\n                        {(()=>{\n                          if (index === 0) {\n                            return (\n                              <>\n                                First,\n                              <\/>\n                            )\n                          } else if (index === persons.length -1) {\n                            return (\n                              <>\n                                Finally,\n                              <\/>\n                            )\n                          } else {\n                            return (\n                              <>\n                                Then\n                              <\/>\n                            )\n                          }\n                        })()}\n                        {' '}\n                        {(()=>{\n                          if (person.numWaffles == 1){\n                            return (\n                              <>\n                                {person.name} ate 1 waffle.\n                              <\/>\n                            )\n                          } else {\n                            return (\n                              <>\n                                {person.name} ate {person.numWaffles} waffles.\n                              <\/>\n                            )\n                          }\n                        })()}\n                        <br\/>\n                      <\/>\n                    <\/React.Fragment>\n                  )\n                }\n              )}\n            <\/>\n          )\n        } else {\n          return (\n            <>\n              Nobody here ate any waffles.<br\/>\n            <\/>\n          )\n        }\n      })()}\n    <\/>\n  )\n} END"}
{"prompt":"// features\/demoMsg.soy\n{namespace features}\n\/**\n * @param name\n * @param labsUrl\n *\/\n{template .demoMsg}\n{msg desc=\"Says hello to a person.\"}Hello {$name}!{\/msg}<br>{msg desc=\"Link to the unreleased 'Labs' feature.\"}Click <a href=\"{$labsUrl}\">here<\/a> to access Labs.{\/msg}<br>{msg meaning=\"noun\" desc=\"The word 'Archive' used as a noun, i.e. an information store.\"}Archive{\/msg}<br>{msg meaning=\"verb\" desc=\"The word 'Archive' used as a verb, i.e. to store information.\"}Archive{\/msg}<br>\n{\/template}","completion":" // features\/DemoMsg.tsx\nimport * as React from 'react';\nimport { Trans } from 'react-i18next'\n\nexport interface DemoMsgProps {\n  name: string;\n  labsUrl: string;\n}\n\n\/**\n * Demo 'msg'.\n * @param props\n * @param props.name - The name of the person to say hello to.\n * @param props.labsUrl - The URL of the unreleased 'Labs' feature.\n *\/\nexport const DemoMsg = (props: DemoMsgProps) => {\n  const { name, labsUrl } = props;\n  return (\n    <>\n      <Trans i18nKey=\"Says hello to a person.\">\n        Hello {{name}}!\n      <\/Trans>\n      <br \/>\n      <Trans i18nKey=\"Link to the unreleased 'Labs' feature.\">\n        Click <a href={labsUrl}>here<\/a> to access Labs.\n      <\/Trans>\n      <br \/>\n\n      {\/* The 'meaning' attribute is used when you have two messages that are exactly the same string in *\/}\n      {\/* English, but may be translated to different strings in other languages. The 'meaning' attribute *\/}\n      {\/* should then be a short string that distinguishes the two strings, and will be used for *\/}\n      {\/* generating different message ids. The 'meaning' will not be shown to translators, so you must *\/}\n      {\/* still communicate all the details in the 'desc' text. *\/}\n      <Trans i18nKey=\"(meaning: noun) The word 'Archive' used as a noun, i.e. an information store.\">\n        Archive\n      <\/Trans>\n      <br \/>\n      <Trans i18nKey=\"(meaning: verb) The word 'Archive' used as a verb, i.e. to store information.\">\n        Archive\n      <\/Trans>\n      <br \/>\n    <\/>\n  );\n};\n END"}
{"prompt":"// features\/tripReport_.soy\n{namespace features}\n\/**\n * @param? name\n * @param? destination\n *\/\n{template .tripReport_}\n{if not hasData() and $name}{msg desc=\"\"}A trip was taken.{\/msg}{elseif not $destination}{msg desc=\"Example: Alice took a trip.\"}{$name} took a trip.{\/msg}{else}{msg desc=\"Example: Alice took a trip to wonderland.\"}{$name} took a trip to {$destination}.{\/msg}{\/if}\n{\/template}","completion":" // features\/TripReport_.tsx\nimport * as React from 'react';\nimport { Trans } from 'react-i18next';\nimport { hasData } from ..\/soyfuncs';\n\nexport interface TripReportProps {\n  name?: any;\n  destination?: any;\n}\n\n\/**\n * Private helper for DemoCallWithoutProps, DemoCallWithProps, and DemoCallWithParamBlock.\n * Reports on a trip.\n * @param props TripReportProps\n * @param? props.name The name of the person who took a trip (optional).\n * @param? props.destination The destination of the trip (optional).\n *\n * @internal\n *\/\nexport const TripReport_ = (props: TripReportProps) => {\n  const { name, destination } = props;\n  return (\n    <>\n      {\/* Note: The template name demonstrates the good practice of adding a trailing underscore to *\/}\n      {\/* private templates (template that should never be called from hand-written code). *\/}\n\n      {\/* Note: All parameters to this template are optional. Therefore, below, we must check for *\/}\n      {\/* \"not (hasData() and $name)\" rather than simply \"not $name\" because if absolutely no data is *\/}\n      {\/* passed, then evaluating \"$name\" will cause an exception. *\/}\n\n      {(() =>{\n        if (!(hasData() && name))  {\n          \/\/ Note: The message below demonstrates that the 'desc' attribute can be left empty. However,\n          \/\/ this is not recommended except for the simplest messages, otherwise you risk confusing some\n          \/\/ translators and getting poor translations.\n          return (\n              <Trans>\n                A trip was taken.\n              <\/Trans>\n          )\n        } else if (!destination)  {\n          return (\n              <Trans i18nKey= \"Example: Alice took a trip.\">\n                {name} took a trip.\n              <\/Trans>\n          )\n        } else {\n          return (\n              <Trans i18nKey= \"Example: Alice took a trip to wonderland.\">\n                {name} took a trip to {destination}.\n              <\/Trans>\n          )\n        }\n      })()}\n    <\/>\n  )\n} END"}
{"prompt":"// features\/demoFor.soy\n{namespace features}\n\/**\n * @param numLines\n *\/\n{template .demoFor}\n{for $i in range($numLines)}Line {$i + 1} of {$numLines}.<br>{\/for}{for $i in range(2,10,2)}{$i}... {\/for}Who do we appreciate?<br>\n{\/template}","completion":" // features\/DemoFor.tsx\nimport * as React from 'react';\nimport { range } from ..\/soyfuncs';\n\nexport interface DemoForProps {\n  numLines: any;\n}\n\n\/**\n * Demo 'for'.\n * @param props DemoForProps\n * @param props.numLines The number of lines to display.\n *\/\nexport const DemoFor = (props :DemoForProps) => {\n  const { numLines } = props;\n  return (\n    <>\n      {range(numLines).map((i) =>{\n        return (\n          <React.Fragment key={i}>\n            Line {i + 1} of {numLines}.<br\/>\n          <\/React.Fragment>\n        )\n      })}\n\n      {range(10, 2, 2).map((i)=>{\n        return (\n          <React.Fragment key={i}>\n            {i}...{' '}\n          <\/React.Fragment>\n        )\n      })}\n      Who do we appreciate?<br\/>\n    <\/>\n  )\n} END"}
{"prompt":"// features\/demoPlural.soy\n{namespace features}\n\/**\n * @param eggs\n *\/\n{template .demoPlural}\n{msg desc=\"The number of eggs you need.\"}{plural $eggs}{case 1}You have one egg{default}You have {$eggs} eggs{\/plural}{\/msg}<br>\n{\/template}","completion":" // features\/DemoPlural.tsx\nimport * as React from 'react';\nimport { Trans } from 'react-i18next'\n\nexport interface DemoPluralProps {\n  eggs: number;\n}\n\n\/**\n * Demo 'plural'.\n * @param props\n * @param props.eggs The number of eggs you need to buy\n *\/\nexport const DemoPlural = (props: DemoPluralProps) => {\n  const { eggs } = props;\n  return (\n    <>\n      {(() => {\n        switch (eggs) {\n          case 1:\n            return (\n              <Trans i18nKey=\"Says hello to a person.\" count={1}>\n                You have one egg\n              <\/Trans>\n            )\n          default:\n            return (\n              <Trans i18nKey=\"Says hello to a person.\" count={eggs}>\n                You have {{eggs}} eggs\n              <\/Trans>\n            )\n        }\n      })()}\n    <\/>\n  )\n}\n END"}
{"prompt":"// features\/demoRawTextCommands.soy\n{namespace features}\n\/** *\/\n{template .demoRawTextCommands}\n<pre>Space       : AA BB<br>Empty string: AABB<br>New line    : AA\nBB<br>Carriage ret: AA\rBB<br>Tab         : AA\tBB<br>Left brace  : AA{BB<br>Right brace : AA}BB<br>Literal     : AA\tBB { CC\n  DD } EE {sp}{\\n}{rb} FF<\/pre>\n{\/template}","completion":" // features\/DemoRawTextCommands.tsx\nimport * as React from 'react';\n\n\/**\n * Demo raw text commands.\n *\/\nexport const DemoRawTextCommands = () => {\n  return (\n    <>\n            <pre>\n            {\/* Special characters.*\/}\n            Space       : AA{' '}BB<br\/>\n            Empty string: AA{''}BB<br\/>\n            New line    : AA{'\\n'}BB<br\/>\n            Carriage ret: AA{'\\r'}BB<br\/>\n            Tab         : AA{'\\t'}BB<br\/>\n            Left brace  : AA{'{'}BB<br\/>\n            Right brace : AA{'}'}BB<br\/>\n\n            {\/* Literal block.*\/}\n            {\/* Note: Lines are not joined and indentation is not stripped, so the new line and 2-space indent*\/}\n            {\/* between 'CC' and 'DD' will appear in the output exactly as written.*\/}\n            Literal     : {`AA\tBB { CC\n            DD } EE {sp}{\\n}{rb} FF`}\n            <\/pre>\n    <\/>\n  )\n} END"}
{"prompt":"// features\/demoExpressions.soy\n{namespace features}\n\/**\n * @param students\n * @param currentYear\n *\/\n{template .demoExpressions}\nFirst student's major: {$students.0.major}<br>Last student's year: {$students[length($students) - 1].year}<br>Random student's major: {$students[randomInt(length($students))].major}<br>{for $student in $students}{$student.name}:{if isFirst($student)} First.{elseif isLast($student)} Last.{elseif index($student) == ceiling(length($students) \/ 2) - 1} Middle.{\/if}{if index($student) % 2 == 1} Even.{\/if} {$student.major}.{if $student.major == 'Physics' or $student.major == 'Biology'} Scientist.{\/if}{if $currentYear - $student.year < 10} Young.{\/if} {$student.year < 2000?round($student.year - 1905,-1) + 's':'00s'}. {if $student.year < 2000}{round($student.year - 1905,-1)}{else}00{\/if}s.<br>{\/for}\n{\/template}","completion":" // features\/DemoExpressions.tsx\nimport * as React from 'react';\nimport { ceiling, randomInt, round } from ..\/soyfuncs';\n\nexport interface DemoExpressionsProps {\n  students: any;\n  currentYear: any;\n}\n\n\/**\n * Demo expressions.\n * @param props DemoExpressionsProps\n * @param props.students Nonempty list of students. Each student must have 'name', 'major', and 'year'.\n * @param props.currentYear The current year.\n *\/\nexport const DemoExpressions = (props :DemoExpressionsProps) => {\n  const { students, currentYear } = props;\n  return (\n    <>\n      First student's major: {students[0].major}<br\/>\n      Last student's year: {students[students.length - 1].year}<br\/>\n      Random student's major: {students[randomInt(students.length)].major}<br\/>\n\n      {students.map((student :any, index :number, arr: any[])=>{\n        return (\n          <React.Fragment key={index}>\n            {student.name}:\n            {(()=>{\n              if (index === 0) {\n                return (\n                  <>\n                    {' '}First.\n                  <\/>\n                )\n              } else if (index === arr.length) {\n                return (\n                  <>\n                    {' '}Last.\n                  <\/>\n                )\n                \/\/ Note: must use floor() in next check since division is floating-point.\n              } else if (index === ceiling(students.length \/ 2) -1) {\n                return (\n                  <>\n                    {' '}Middle.\n                  <\/>\n                )\n              }\n            })()}\n            {(()=>{\n              if (index % 2 === 1) { return <> Even.<\/> }\n            })()}\n            {' '}{student.major}.\n            {(()=>{\n              if (student.major === 'Physics' || student.major === 'Biology') { return <> Scientist.<\/> }\n            })()}\n            {(()=>{\n              if (currentYear - student.year < 10)  { return <> Young.<\/> }\n            })()}\n            {\/* The following print statement prints \"70s\", \"80s\", \"90s\", or \"00s\". Note that \"00s\" is a *\/}\n            {\/* special case since using the same expression would yield \"0s\", not \"00s\". *\/}\n            {' '}{student.year < 2000 ? round(student.year - 1905, -1) + 's' : '00s'}.\n            {\/* Equivalent to previous line. *\/}\n            {' '}{(()=>{\n            if (student.year < 2000) {\n              return (\n                <>\n                  {round(student.year - 1905, -1)}\n                <\/>\n              )\n            } else {\n              return (\n                <>\n                  00\n                <\/>\n              )\n            }\n          })()}s.\n            <br\/>\n          <\/React.Fragment>\n        )\n      })}\n    <\/>\n  )\n} END"}
{"prompt":"// features\/demoPrintDirectives.soy\n{namespace features}\n\/**\n * @param longVarName\n * @param elementId\n * @param cssClass\n *\/\n{template .demoPrintDirectives}\ninsertWordBreaks:<br><div style=\"width:150px; border:1px solid #00CC00\">{$longVarName}<br>{$longVarName|insertWordBreaks:5}<br><\/div>id:<br><span id=\"{$elementId|id}\" class=\"{$cssClass|id}\" style=\"border:1px solid #000000\">Hello<\/span>\n{\/template}","completion":" // features\/DemoPrintDirectives.tsx\nimport * as React from 'react';\nimport { id, insertWordBreaks } from ..\/soyfuncs';\n\nexport interface DemoPrintDirectivesProps {\n  longVarName: any;\n  elementId: any;\n  cssClass: any;\n}\n\n\/**\n * Demo print directives.\n * @param props\n * @param props.longVarName Some ridiculously long variable name.\n * @param props.elementId The id for an element.\n * @param props.cssClass A CSS class name.\n *\/\nexport const DemoPrintDirectives = (props: DemoPrintDirectivesProps) => {\n  const { longVarName, elementId, cssClass } = props;\n  return (\n    <>\n      insertWordBreaks:<br\/>\n      <div style={{width:'150px', border:'1px solid #00CC00'}}>\n        {longVarName}<br\/>  {\/* will run outside the div border *\/}\n        {insertWordBreaks(longVarName, 5)}<br\/>  {\/* will be allowed to wrap*\/}\n      <\/div>\n\n      id:<br\/>\n      {\/* The 'id' and 'class' attributes of this span will not be needlessly autoescaped because they *\/}\n      {\/* are marked with the print directive '|id'. *\/}\n      {\/* Note: Only use '|id' with identifiers like id and class (otherwise use '|noAutoescape') *\/}\n      <span id={id(elementId)} className={id(cssClass)} style={{border:'1px solid #000000'}}>\n                Hello\n            <\/span>\n    <\/>\n  )\n}\n END"}
{"prompt":"// features\/demoSwitch.soy\n{namespace features}\n\/**\n * @param name\n *\/\n{template .demoSwitch}\nDear {$name}, &nbsp;{switch $name}{case 'Go'}You've been bad this year.{case 'Fay','Ivy'}You've been good this year.{case }You don't really believe in me, do you?{\/switch}&nbsp; --Santa<br>\n{\/template}","completion":" // features\/DemoSwitch.tsx\nimport * as React from 'react';\n\nexport interface DemoSwitchProps {\n  name: string;\n}\n\n\/**\n * Demo 'switch'.\n * @param props\n * @param props.name The name of a kid.\n *\/\nexport const DemoSwitch = (props :DemoSwitchProps) => {\n  const { name } = props;\n  return (\n    <>\n      Dear {name}, &nbsp;\n\n      {(() => {\n        switch (name) {\n        case 'Go':\n          return (\n            <>\n              You've been bad this year.\n            <\/>\n          )\n        case 'Fay':\n        case 'Ivy':\n          return (\n            <>\n              You've been good this year.\n            <\/>\n          )\n        default:\n          return (\n            <>\n              You don't really believe in me, do you?\n            <\/>\n          )\n        }\n      })()}\n\n      &nbsp; --Santa<br\/>\n    <\/>\n  )\n} END"}
{"prompt":"// features\/demoAutoescapeTrue.soy\n{namespace features}\n\/**\n * @param italicHtml\n *\/\n{template .demoAutoescapeTrue}\n{$italicHtml}<br>{$italicHtml|noAutoescape}<br>\n{\/template}","completion":" // features\/DemoAutoescapeTrue.tsx\nimport * as React from 'react';\nimport { escapeHtml, noAutoescape } from ..\/soyfuncs';\n\nexport interface DemoAutoescapeTrueProps {\n  italicHtml: any;\n}\n\n\/**\n * Demo autoescape true.\n * @param props DemoAutoescapeTrueProps\n * @param props.italicHtml A string surrounded by HTML italics tags.\n *\/\nexport const DemoAutoescapeTrue = (props: DemoAutoescapeTrueProps) => {\n  const { italicHtml } = props;\n  return (\n    <>\n      {\/* Note: We explicitly list autoescape=\"true\" in the 'template' tag for demonstration. Usually ( *\/}\n      {\/* it's omitted because \"true\" is the attribute's default value. *\/}\n      {\/* Note: The parameter name 'italicHtml' demonstrates the good practice of adding the suffix *\/}\n      {\/* 'Html' to identify strings that may contain HTML tags and are known to be safe. *\/}\n      {escapeHtml(italicHtml)}<br\/>  {\/* autoescape causes HTML tags to appear literally *\/}\n      {noAutoescape(italicHtml)}<br\/>  {\/* noAutoescape directive prevents autoescaping *\/}\n    <\/>\n  )\n}\n END"}
{"prompt":"// features\/demoCallWithParamBlock.soy\n{namespace features}\n\/**\n * @param name\n *\/\n{template .demoCallWithParamBlock}\n{call .tripReport_}{param name: $name\/}{param destination}{switch randomInt(3)}{case 0}Boston{case 1}Singapore{case 2}Zurich{\/switch}{\/param}{\/call}<br>\n{\/template}","completion":" // features\/DemoCallWithParamBlock.tsx\nimport * as React from 'react';\nimport { randomInt } from ..\/soyfuncs';\nimport { TripReport_ } from '.\/TripReport_';\n\nexport interface DemoCallWithParamBlockProps {\n  name: any;\n}\n\n\/**\n * Demo 'call' with a 'param' block.\n * @param props DemoCallWithParamBlockProps\n * @param props.name The name of the person who took the trip.\n *\/\nexport const DemoCallWithParamBlock = (props :DemoCallWithParamBlockProps) => {\n  const { name } = props;\n  return (\n    <>\n      {\/* Pass 2 parameters, one of which is built using Soy code. *\/}\n      <TripReport_ name={name} destination={(()=>{\n        switch (randomInt(3)) {\n        case 0:\n          return (\n            <>\n              Boston\n            <\/>\n          )\n        case 1:\n          return (\n            <>\n              Singapore\n            <\/>\n          )\n        case 2:\n          return (\n            <>\n              Zurich\n            <\/>\n          )\n        }\n      })()} \/>\n      <br\/>\n    <\/>\n  )\n} END"}
{"prompt":"// features\/demoIf.soy\n{namespace features}\n\/**\n * @param pi\n *\/\n{template .demoIf}\n{if round($pi,2) == 3.14}{msg desc=\"Example: 3.1416 is a good approximation of pi.\"}{$pi} is a good approximation of pi.{\/msg}{elseif round($pi) == 3}{msg desc=\"Example: 3.1 is a bad approximation of pi.\"}{$pi} is a bad approximation of pi.{\/msg}{else}{msg desc=\"Example: 5 is nowhere near the value of pi.\"}{$pi} is nowhere near the value of pi.{\/msg}{\/if}<br>\n{\/template}","completion":" // features\/DemoIf.tsx\nimport * as React from 'react';\nimport { Trans } from 'react-i18next';\nimport { round } from ..\/soyfuncs';\n\nexport interface DemoIfProps {\n  pi: any;\n}\n\n\/**\n * Demo 'if'.\n * @param props DemoIfProps\n * @param props.pi An approximate value for pi.\n *\/\nexport const DemoIf = (props: DemoIfProps) => {\n  const { pi } = props;\n  return (\n    <>\n      {(() => {\n        if (round(pi, 2) == 3.14) {\n          console.log(pi, round(pi, 2));\n          return (\n            <Trans i18nkey=\"Example: 3.1416 is a good approximation of pi.\">\n              {{pi}} is a good approximation of pi.\n            <\/Trans>\n          )\n        } else if (round(pi) == 3) {\n          console.log(pi, round(pi, 3));\n          return (\n            <Trans i18nkey=\"Example: 3.1 is a bad approximation of pi.\">\n              {{pi}} is a bad approximation of pi.\n            <\/Trans>\n          )\n        } else {\n          return (\n            <Trans i18nkey=\"Example: 5 is nowhere near the value of pi.\">\n              {{pi}} is nowhere near the value of pi.\n            <\/Trans>\n          )\n        }\n      })()}\n      <br\/>\n    <\/>\n  )\n} END"}
{"prompt":"// features\/demoParamWithKindAttributeCallee_.soy\n{namespace features}\n\/**\n * @param message\n * @param listItems\n *\/\n{template .demoParamWithKindAttributeCallee_}\n<div>{$message}<\/div><ol>{$listItems}<\/ol>\n{\/template}","completion":" // features\/DemoParamWithKindAttributeCallee_.tsx\nimport * as React from 'react';\n\nexport interface DemoParamWithKindAttributeCallee_Props {\n  message: any;\n  listItems: any;\n}\n\n\/**\n * Demo {param} blocks with 'kind' attribute.\n * @param props\n * @param props.message A message with HTML markup.\n * @param props.listItems A HTML-formatted list.\n *\n * @internal\n *\/\nexport const DemoParamWithKindAttributeCallee_ = (props :DemoParamWithKindAttributeCallee_Props) => {\n  const { message, listItems } = props;\n  \/\/ private=\"true\" autoescape=\"contextual\"\n  \/\/ TODO: how to actually mimic this in jsx?\n  return (\n    <>\n      {\/* Note that both $message and $listItems contain HTML markup produced by a {param} block in the *\/}\n      {\/* the calling template.  Since the {param} blocks are declared to have HTML content, their values *\/}\n      {\/* are wrapped as soydata.SanitizedHtml objects.  This in turn causes them to be emitted here *\/}\n      {\/* without further escaping.  In particular, it is not necessary to use the |noAutoescape print *\/}\n      {\/* directive to prevent double-escaping. *\/}\n      <div>\n        {message}\n      <\/div>\n      <ol>\n        {listItems}\n      <\/ol>\n    <\/>\n  )\n} END"}
{"prompt":"// features\/exampleHeader.soy\n{namespace features}\n\/**\n * @param exampleNum\n * @param exampleName\n *\/\n{template .exampleHeader}\n<hr><b>{$exampleNum}. {$exampleName}<\/b><br>\n{\/template}","completion":" // features\/ExampleHeader.tsx\nimport * as React from 'react';\n\nexport interface ExampleHeaderProps {\n  exampleNum: any;\n  exampleName: any;\n}\n\n\/**\n * Template for printing the header to add before each example.\n * @param props ExampleHeaderProps\n * @param props.exampleNum The number of the example.\n * @param props.exampleName The name of the example.\n *\/\nexport const ExampleHeader = (props :ExampleHeaderProps) => {\n  const { exampleNum, exampleName } = props;\n  return (\n    <>\n      <hr\/>\n      <b>{exampleNum}. {exampleName}<\/b><br\/>\n    <\/>\n  )\n}\n END"}
{"prompt":"// features\/demoBidiSupport.soy\n{namespace features}\n\/**\n * @param title\n * @param author\n * @param year\n * @param keywords\n *\/\n{template .demoBidiSupport}\n<div id=\"title1\" style=\"font-variant:small-caps\" {bidiDirAttr($title)}>{$title}<\/div><div id=\"title2\" style=\"font-variant:small-caps\">{$title|bidiSpanWrap}<\/div>{msg desc=\"Indicates who wrote the book and when, e.g. 'by Rudyard Kipling (1892)'\"}by {$author|bidiSpanWrap} ({$year}){\/msg}<div id=\"choose_a_keyword\">{msg desc=\"Ask user to pick best keyword\"}Your favorite keyword{\/msg}: <select>{for $keyword in $keywords}<option value=\"{$keyword}\">{$keyword|bidiUnicodeWrap}<\/option>{\/for}<\/select><\/div><a href=\"#\" style=\"float:{bidiEndEdge()}\">{msg desc=\"Link to Help\"}Help{\/msg}<\/a><br>\n{\/template}","completion":" // features\/DemoBidiSupport.tsx\nimport * as React from 'react';\nimport { Trans } from 'react-i18next';\nimport { bidiDirAttr, bidiEndEdge, bidiSpanWrap, bidiUnicodeWrap } from ..\/soyfuncs';\n\nexport interface DemoBidiSupportProps {\n  title: any;\n  author: any;\n  year: any;\n  keywords: any;\n}\n\n\/**\n * Demo BiDi support.\n * @param props DemoBidiSupportProps\n * @param props.title Book title.\n * @param props.author Author's name.\n * @param props.year Year published.\n * @param props.keywords List of keywords.\n *\/\nexport const DemoBidiSupport = (props: DemoBidiSupportProps) => {\n  const { title, author, year, keywords } = props;\n  return (\n    <>\n      {\/* If $title has the opposite directionality relative to the overall locale, it needs to be *\/}\n      {\/* declared as such using the dir attribute on the element around it. Otherwise, it may be *\/}\n      {\/* garbled. For example, in an RTL page, an LTR value like \"101 Dalmatians!\" will be displayed *\/}\n      {\/* as \"!Dalmatians 101\". *\/}\n      {\/* *\/}\n      {\/* Setting the dir attribute on a block element like <div> has the side-effect of setting its *\/}\n      {\/* default alignment. In some cases, this is desirable, since text is generally more readable *\/}\n      {\/* when start-aligned. In such cases, we declare directionality using the bidiDirAttr() function, *\/}\n      {\/* which returns dir=\"ltr\" for an LTR value in an RTL locale, dir=\"rtl\" for an RTL value in an LTR *\/}\n      {\/* locale, and an empty string otherwise. *\/}\n      {\/* *\/}\n      <div id=\"title1\" style={{ fontVariant:\"small-caps\" }} dir={bidiDirAttr(title)}>\n        {title}\n      <\/div>\n\n      {\/* In other cases, changing alignment may do more harm than good by upsetting the layout of the *\/}\n      {\/* page, and we do not want to do it. Our $title seems to be one such case. To avoid setting the *\/}\n      {\/* dir attribute on the <div>, we declare $title's directionality using the |bidiSpanWrap print *\/}\n      {\/* directive, which wraps the value to be printed in a <span dir=\"ltr\">, <span dir=\"rtl\">, or *\/}\n      {\/* nothing at all when it has the same directionality as the locale. *\/}\n      <div id=\"title2\" style={{ fontVariant:\"small-caps\" }}>\n        {bidiSpanWrap(title)}\n      <\/div>\n\n      {\/* The |bidiSpanWrap directive is in fact the usual way to declare directionality. One of its *\/}\n      {\/* advantages is that it can be used when the possibly opposite-directionality value, like our *\/}\n      {\/* $author here, is not already wrapped in an element of its own, without adding to the size of *\/}\n      {\/* the output in the usual case of same directionality. *\/}\n      {\/* *\/}\n      {\/* Another even more important advantage is that it prevents an opposite-directionality value *\/}\n      {\/* from \"sticking\" to a number or another opposite-directionality string following it in-line. In *\/}\n      {\/* this case, for example, it makes sure we get 'by HEBREW NAME (2009)', not *\/}\n      {\/* 'by 2009) HEBREW NAME)'. *\/}\n      <Trans i18nkey={\"Indicates who wrote the book and when, e.g. 'by Rudyard Kipling (1892)'\"}>\n        by {bidiSpanWrap(author)} ({year})\n      <\/Trans>\n\n      <div id=\"choose_a_keyword\">\n        {\/* Please note that messages, by definition being in the language of the overall locale, can *\/}\n        {\/* not be of the opposite directionality and do not need directionality declaration. *\/}\n        <Trans i18nkey={\"Ask user to pick best keyword\"}>\n          Your favorite keyword\n        <\/Trans>\n        :{' '}\n        <select>\n          {keywords.map((keyword :any, index: number) => {\n            return (\n              <React.Fragment key={index}>\n                {\/* Mark-up is not allowed under the option element, and setting its dir attribute does not *\/}\n                {\/* do what one would expect. The only way to prevent the garbling of opposite- *\/}\n                {\/* directionality options is to use |bidiUnicodeWrap, which wraps its input in Unicode BiDi *\/}\n                {\/* formatting characters that declare its directionality. So why not always use *\/}\n                {\/* |bidiUnicodeWrap instead of |bidiSpanWrap? Because the W3C strongly deprecates the use *\/}\n                {\/* of the formatting characters it uses except in places where mark-up cannot be used. *\/}\n                <option value={keyword}>{bidiUnicodeWrap(keyword)}<\/option>\n              <\/React.Fragment>\n            );\n          })}\n        <\/select>\n      <\/div>\n\n      {\/* Since most of the layout of an RTL page is supposed to be the mirror image of an LTR page, *\/}\n      {\/* most instances of 'left' and 'right' in the style should be replaced with {bidiStartEdge()} *\/}\n      {\/* and {bidiEndEdge()}, respectively. Here, we want the Help link at the \"far\" edge of the page, *\/}\n      {\/* i.e. on the right in LTR and on the left in RTL. *\/}\n      <a href=\"#\" style={{float: bidiEndEdge()}}>\n        <Trans i18nkey={\"Link to Help\"}>\n          Help\n        <\/Trans>\n      <\/a>\n      <br\/>\n\n    <\/>\n  )\n} END"}
{"prompt":"// features\/demoComments.soy\n{namespace features}\n\/** *\/\n{template .demoComments}\nblah blah<br>http:\/\/www.google.com<br>\n{\/template}","completion":" // features\/DemoComments.tsx\n\/\/ Copyright 2008 Google Inc.\n\/\/\n\/\/ Licensed under the Apache License, Version 2.0 (the \"License\");\n\/\/ you may not use this file except in compliance with the License.\n\/\/ You may obtain a copy of the License at\n\/\/\n\/\/     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n\/\/\n\/\/ Unless required by applicable law or agreed to in writing, software\n\/\/ distributed under the License is distributed on an \"AS IS\" BASIS,\n\/\/ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\/\/ See the License for the specific language governing permissions and\n\/\/ limitations under the License.\n\n\/\/ Features examples.\n\/\/ Author: Kai Huang\nimport * as React from 'react';\n\n\/**\n * Demo comments.\n *\/\nexport const DemoComments = () => {\n  return (\n    <>\n      blah blah<br\/>  {\/* comment comment *\/}\n      {\/* comment\n             comment *\/}\n\n      {\/* Note: The '\/\/' below doesn't start a comment because it's preceded by a non-whitespace. *\/}\n\n      http:\/\/www.google.com<br\/>\n    <\/>\n  )\n}\n END"}
{"prompt":"// features\/demoParamWithKindAttribute.soy\n{namespace features}\n\/**\n * @param message\n * @param list\n *\/\n{template .demoParamWithKindAttribute}\n<div>{call .demoParamWithKindAttributeCallee_}{param message}<b>{$message}<\/b>{\/param}{param listItems}{for $i in $list}<li>{$i}<\/li>{\/for}{\/param}{\/call}<\/div>\n{\/template}","completion":" // features\/DemoParamWithKindAttribute.tsx\nimport * as React from 'react';\nimport { DemoParamWithKindAttributeCallee_ } from '.\/DemoParamWithKindAttributeCallee_';\n\nexport interface DemoParamWithKindAttributeProps {\n  message: any;\n  list: any;\n}\n\n\/\/ TODO: figure out how to implement this contextual autoescaping\n\/**\n * Demo {param} blocks with 'kind' attribute.\n * @param props\n * @param props.message A message text.\n * @param props.list A list of things.\n *\/\nexport const DemoParamWithKindAttribute = (props :DemoParamWithKindAttributeProps) => {\n  const { message, list } = props;\n  \/\/ autoescape=\"contextual\"\n  return (\n    <>\n      <div>\n        {\/* Note that the {param} blocks for the message and listItems parameter are declared to have *\/}\n        {\/* content of kind HTML. This instructs the contextual autoescaper to process the content of *\/}\n        {\/* these blocks as HTML, and to wrap the the value of the parameter as a soydata.SanitizedHtml *\/}\n        {\/* object. *\/}\n        <DemoParamWithKindAttributeCallee_\n          \/\/ kind=\"html\"\n          message={(()=>{\n            return (\n              <>\n                <b>{message}<\/b>\n              <\/>\n            )\n          })()}\n          \/\/ kind=\"html\"\n          listItems={(()=>{\n            return (\n              <>\n                {list.map((i :number)=>{\n                  return (\n                    <React.Fragment key={i}>\n                      <li>{i}<\/li>\n                    <\/React.Fragment>\n                  )\n                })}\n              <\/>\n            )\n          })()}\n        \/>\n      <\/div>\n    <\/>\n  )\n}\n END"}
{"prompt":"// simple\/helloName.soy\n{namespace simple}\n\/**\n * @param? name\n *\/\n{template .simple.helloName}\n{if hasData() and $name}{msg desc=\"Says hello to a person.\"}Hello {$name}!{\/msg}{else}{call soy.examples.simple.helloWorld\/}{\/if}\n{\/template}","completion":" // simple\/HelloName.tsx\nimport * as React from 'react';\nimport { Trans } from 'react-i18next'\nimport { HelloWorld } from '.\/HelloWorld';\n\nexport interface HelloNameParams {\n  name: string;\n}\n\n\/**\n * Says hello to a person (or to the world if no person is given).\n * @param props\n * @param? props.name The name of the person to say hello to.\n *\/\nexport const HelloName = (props: HelloNameParams) => {\n  const { name } = props;\n  if (name) {\n    return (\n      <Trans i18nKey=\"Says hello to a person\">\n        Hello {{name}}!\n      <\/Trans>\n    )\n  } else {\n    return <HelloWorld \/>;\n  }\n} END"}
{"prompt":"// features\/demoCallWithoutParam.soy\n{namespace features}\n\/**\n * @param name\n * @param tripInfo\n *\/\n{template .demoCallWithoutParam}\n{call soy.examples.simple.helloWorld\/}<br>{call .tripReport_\/}<br>{call .tripReport_ data=\"all\"\/}<br>{call .tripReport_ data=\"$tripInfo\"\/}<br>\n{\/template}","completion":" // features\/DemoCallWithoutParam.tsx\nimport * as React from 'react';\nimport { HelloWorld } from '..\/simple';\nimport { TripReport_ } from '.\/TripReport_';\n\nexport interface DemoCallWithoutParamProps {\n  name: any;\n  tripInfo: any;\n}\n\n\/**\n * Demo 'call' without 'param's.\n * @param props DemoCallWithoutParamProps\n * @param props.name The name of the person who took a trip.\n * @param props.tripInfo The full record of the trip ('name' and 'destination').\n *\/\nexport const DemoCallWithoutParam = (props :DemoCallWithoutParamProps) => {\n  const { name, tripInfo } = props;\n  return (\n    <>\n      {\/* Call template defined in a different file. *\/}\n      <HelloWorld\/><br\/>\n\n      {\/* Call template defined in this file. *\/}\n      <TripReport_ \/><br\/>\n\n      {\/* Pass all of the current template data to the callee. *\/}\n      {\/* Note: Only the top-level key 'name' will be used because it matches the name of a parameter *\/}\n      {\/* expected by the callee. *\/}\n      <TripReport_ {...props}\/><br\/>\n\n      {\/* Pass a subset of the current template data to the callee. *\/}\n      <TripReport_ {...tripInfo}\/><br\/>\n    <\/>\n  )\n}\n END"}
{"prompt":"// features\/demoDoubleBraces.soy\n{namespace features}\n\/**\n * @param setName\n * @param setMembers\n *\/\n{template .demoDoubleBraces}\n{msg desc=\"Example: The set of prime numbers is {2, 3, 5, 7, 11, 13, ...}.\"}The set of {$setName} is {{call .buildCommaSeparatedList_}{param items: $setMembers\/}{\/call}, ...}.{\/msg}\n{\/template}","completion":" // features\/DemoDoubleBraces.tsx\nimport * as React from 'react';\nimport { BuildCommaSeparatedList_ } from '.\/BuildCommaSeparatedList_';\nimport { Trans } from 'react-i18next';\n\nexport interface DemoDoubleBracesProps {\n  setName: any;\n  setMembers: any;\n}\n\n\/**\n * Demo double braces.\n * @param props DemoDoubleBracesProps\n * @param props.setName The name of the infinite set.\n * @param props.setMembers List of the first few members of the set.\n *\/\nexport const DemoDoubleBraces = (props :DemoDoubleBracesProps) => {\n  const { setName, setMembers } = props;\n\n  return (\n    <>\n      {\/* If a Soy tag needs to have brace characters within, use double braces to delimit the tag. *\/}\n      <Trans i18nKey={\"Example: The set of prime numbers is {2, 3, 5, 7, 11, 13, ...}.\"}>\n        {\/* Note: This message also demonstrates a useful trick. Since a 'msg' block cannot contain a *\/}\n        {\/* 'foreach' statement (impossible to translate as one message), we use a 'call' to a helper *\/}\n        {\/* template that contains the 'foreach' loop. In order to use this trick, please observe the *\/}\n        {\/* following: (a) the output of the 'call' must not contain translated content, otherwise the *\/}\n        {\/* message would be translated in multiple parts and may not read correctly in some languages, *\/}\n        {\/* (b) since the whole 'call' turns into a single placeholder, be sure to provide a clear *\/}\n        {\/* description and example to the translator. *\/}\n        The set of {setName} is {'{'}\n        <BuildCommaSeparatedList_ items={setMembers} \/>\n        , ...{'}'}.\n      <\/Trans>\n    <\/>\n  )\n}\n END"}
{"prompt":"// simple\/helloNames.soy\n{namespace simple}\n\/**\n * @param names\n *\/\n{template .simple.helloNames}\n{for $name in $names}{call soy.examples.simple.helloName}{param name: $name\/}{\/call}{if not isLast($name)}<br>{\/if}{ifempty}{call soy.examples.simple.helloWorld\/}{\/for}\n{\/template}","completion":" // simple\/HelloNames.tsx\nimport * as React from 'react';\nimport { HelloWorld } from '.\/HelloWorld';\nimport { HelloName } from '.\/HelloName';\n\nexport interface IHelloNamesProps {\n  names: string[]\n}\n\n\/**\n * Say hello to a list of people.\n * @param props HelloNamesProps\n * @param props.names List of names of the people to say hello to.\n *\/\nexport const HelloNames = (props: IHelloNamesProps) => {\n  const { names } = props;\n  return (\n    <>\n      {names.map((name, index) => (\n        <React.Fragment key={index}>\n          <HelloName name={name} \/>\n          {index !== names.length - 1 && <br \/>}\n        <\/React.Fragment>\n      ))}\n      {names.length === 0 && <HelloWorld \/>}\n    <\/>\n  );\n}; END"}
